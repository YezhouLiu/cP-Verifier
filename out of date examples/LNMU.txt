#computing engine - Yezhou

from copy import deepcopy
from term import Term
from collections import OrderedDict

#UNIFICATION
#------------------------------------------------------------------------------
def UnifyTerms(tv, tm): #tv: variable term, tm: ground term, return value: substitutions + token, which indicates that unification succeeds or fails 
    substitutions = {}
    if not tm.IsGround(): #one-way unification, pattern matching only
        return substitutions, False
    if tv.IsGround(): #both ground terms, if tv = tm, any substitution unifies it; otherwise, not unifiable
        if tv.ToString() == tm.ToString():
            return substitutions, True
        else:
           return substitutions, False 
    if tv.Label() != tm.Label(): #label mismatching, not unifiable
        return substitutions, False
    return UnifyMultisets(tv.Subterms(), tm.Subterms(), substitutions)

def UnifyMultisets(ms1, ms2, subs):
    gms1, gms2 = GROUND(ms1, ms2) #gms1 should not have any ground terms, otherwise FAIL1
    if FAIL1(gms1):
        return subs
    #directly use VARIABLE
    pass

def FAIL1(ms1): #true: fail, false: succeed
    for t1 in ms1:
        if isinstance(t1, Term) and t1.IsGround():
            return True
        elif t1 >= 'a' and t1 <= 'z':
            return True
        elif t1 == '1':
            return True
    return False

def GROUND(ms1, ms2): #return two multisets, optimize it later as needed
    mi = MultisetIntersection(ms1, ms2)
    return MultisetMinus(ms1, mi), MultisetMinus(ms2, mi)

def TermApplyMappings(term, mappings): #mappings: {X:a, Y:bcd, Z:f(ab)} variable -> g_multiset (dictionary)
    for t1 in term.Subterms():
        t1_multiplicity = term.Subterms()[t1]
        if isinstance(t1, Term):
            t2 = TermApplyMappings(t1, mappings) #t2 is ground
            if t1.ToString() != t2.ToString():
                term.PopItem(t1)
                term.AddItem(t2,t1_multiplicity)
        elif t1 >= 'A' and t1 <= 'Z':
            if t1 in mappings:
                ms1 = mappings[t1]
                term.PopItem(t1)
                for t3 in ms1:
                    term.AddItem(t3,ms1[t3]*t1_multiplicity)

def MultisetApplyMappings(multiset, mappings): #mappings: {X:a, Y:bcd, Z:f(ab)}
    pass

#MULTISET
#------------------------------------------------------------------------------
def MultisetUnion(ms1, ms2): #Multiset = OrderedDict, ms1 \cup ms2
    ms = deepcopy(ms1)
    for key in ms2:
        if key in ms:
            ms[key] += ms2[key]
        else:
            ms[key] = ms2[key]
    return ms

def MultisetInclusion(ms1, ms2): #return if ms1 includes ms2
    for key in ms2:
        if key in ms1 and ms1[key] >= ms2[key]:
            continue
        else:
            return False
    return True

def MultisetIn(ms1, ms2): #many people like this direction :)
    return MultisetInclusion(ms2, ms1)

def MultisetMinus(ms1, ms2): #ms1 \ ms2
    ms = deepcopy(ms1)
    if MultisetIn(ms2, ms): #otherwise no computation will be done
        for key in ms2:
            if ms[key] == ms2[key]:
                ms.pop(key)
            else:
                ms[key] -= ms2[key]
    return ms

def MultisetIntersection(ms1, ms2): #ms1 \cap ms2
    ms = OrderedDict()
    for key in ms2:
        if key in ms1:
            ms[key] = min(ms1[key], ms2[key])
    return ms